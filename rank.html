<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>tensor and rank</title>
<link rel="stylesheet" href="math.css" type="text/css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css" type="text/css" />
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script>
<script type="text/javascript" src="render.js"></script>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="document" id="tensor-and-rank">
<h1 class="title">tensor and rank</h1>

<p>Everybody is talking about tensor these days. Multidimensional array
is called tensor in Torch. Tensorflow has tensor in its name. However,
to them, tensor is just plain multidimensional array. They don't learn
anything useful from tensor analysis like the J programming language
do.</p>
<p>The rank of an array is the number of its dimensions. In J, verbs
(functions) also have ranks <a class="footnote-reference" href="#id2" id="id1">[1]</a> . Without ranks, loops are almost
impossible to avoid. So, as a great automatic differentiation tool for
numpy, autograd has sophisticated mechanism to support loops. Many
others don't have both, and their functionality is very limited, you
will soon run into a situation when you have to develop your own
layers. Our framework does not rely on numpy, it is better to adopt
ranks, so that it could be flexible with very simple implementation.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://www.jsoftware.com/help/learning/07.htm">http://www.jsoftware.com/help/learning/07.htm</a></td></tr>
</tbody>
</table>
<p>First, let's define Array and ArrayView.</p>
<pre class="code literal-block">
class ArrayView(object):

    def __init__(self, data, offset, length):
        self.data = data
        self.offset = offset
        self.length = length

    def subview(self, n, blocks):
        return ArrayView(self.data, self.offset+(self.length/blocks)*n, self.length/blocks)

    def __getitem__(self, index):
        assert 0 &lt;= index &lt; self.length
        return self.data[self.offset+index]

    def __setitem__(self, index, value):
        assert 0 &lt;= index &lt; self.length
        self.data[self.offset+index] = value


class Array(object):

    def __init__(self, shape, data):
        self.shape = shape
        self.data = data

    def view(self):
        return ArrayView(self.data, 0, len(self.data))

    def __eq__(self, other):
        return (self.shape == other.shape) and (self.data == other.data)
</pre>
<p>This is a multidimensional array in C.</p>
<pre class="code literal-block">
int a[2][3] = {{1,2,3},{4,5,6}};
</pre>
<p>And this is the equivalent array in LiFT.</p>
<pre class="code literal-block">
a = Array((3,2),[1,2,3,4,5,6])
</pre>
<p>Let's take a look at a simple monad, sum. Sum takes an array of rank
<span alt="n" class="formula">
<i>n</i></span>
 as argument, and returns an array of rank <span alt="n-1" class="formula">
<i>n</i> − 1</span>
. For
example,</p>
<pre class="code literal-block">
sum of Array((3,), [1,2,3])
1 + 2 + 3 = 6

sum of Array((3,2), [1,2,3,4,5,6])
1  2  3
+  +  +
4  5  6
-------
5  7  9
</pre>
<p>What if we want to calculate sum of each rank-1 array in a rank-2
array.</p>
<pre class="code literal-block">
sum&quot;1 of Array((3,2), [1,2,3,4,5,6])
1 + 2 + 3 = 6
4 + 5 + 6 = 15
</pre>
<p>Sum can be defined like this</p>
<pre class="code literal-block">
class Sum(object):
    rank = None

    def get_shape(self, sy):
        return sy[:-1]

    def interp(self, sy, vy, vz):
        p = product(sy[:-1])
        for i in xrange(p):
            vz[i] = 0

        for i in xrange(sy[-1]):
            vyi = vy.subview(i, sy[-1])
            for j in xrange(p):
                vz[j] += vyi[j]
</pre>
<p>We first calculate the product of the dimensions, so that we could use
just a single loop.</p>
<pre class="code literal-block">
def product(l):
    x = 1
    for e in l:
        x *= e
    return x

def interp_monad(op, ry, y):
    if ry is None:
        ry = len(y.shape)

    shape = op.get_shape(y.shape[:ry]) + y.shape[ry:]
    z = Array(shape, [0.0 for _ in xrange(product(shape))])

    vy = y.view()
    vz = z.view()

    p = product(y.shape[ry:])
    for i in xrange(p):
        op.interp(y.shape[:ry], vy.subview(i,p), vz.subview(i,p))

    return z
</pre>
<pre class="code literal-block">
assert interp_monad(Sum(), 1, Array((3,),[1,2,3])) == Array((),[6])
assert interp_monad(Sum(), 2, Array((3,2),[1,2,3,4,5,6])) == Array((3,),[5,7,9])
assert interp_monad(Sum(), 1, Array((3,2),[1,2,3,4,5,6])) == Array((2,),[6,15])
</pre>
<p>As with J, verb(function)s have intrinsic ranks, and you can also
create verb(function)s with different ranks using double-quote. So we
have to support nested ranks, and we use <code>None</code> to represent
rank infinity.</p>
<pre class="code literal-block">
def get_shape_monad(op, ranks, sy):
    if not ranks:
        ry = op.rank
        inner = op.get_shape
    else:
        ry = ranks[-1]

        def inner(sy):
            return get_shape_monad(op, ranks[:-1], sy)

    if ry is None:
        ry = len(sy)

    return inner(sy[:ry]) + sy[ry:]


def interp_monad(op, ranks, sy, vy, vz):
    if not ranks:
        ry = op.rank
        inner = op.interp
    else:
        ry = ranks[-1]
        def inner(sy, vy, vz):
            interp_monad(op, ranks[:-1], sy, vy, vz)

    if ry is None:
        ry = len(sy)

    p = product(sy[ry:])
    for i in xrange(p):
        inner(sy[:ry], vy.subview(i, p),
              vz.subview(i, p))


def rankex1(op, ranks, y):
    shape = get_shape_monad(op, ranks, y.shape)
    z = Array(shape, [0.0 for _ in xrange(product(shape))])
    interp_monad(op, ranks, y.shape, y.view(), z.view())
    return z
</pre>
<p>Since verb(function)s have intrinsic ranks, we don't have specify
ranks in first two examples.</p>
<pre class="code literal-block">
assert rankex1(Sum(), (), Array((3,),[1,2,3])) == Array((),[6])
assert rankex1(Sum(), (), Array((3,2),[1,2,3,4,5,6])) == Array((3,),[5,7,9])
assert rankex1(Sum(), (1,), Array((3,2),[1,2,3,4,5,6])) == Array((2,),[6,15])
</pre>
<p>Similarly, dyad has one rank for the left argument, and another one
for the right. What about the dimensions not taken by dyad. They have
to agree, i.e., the remaining dimensions of one argument should be a
suffix of the remaining dimensions of the other argument.</p>
<pre class="code literal-block">
agree
&quot;2   5 4    1 2 3
&quot;3   6 7 8    2 3

not agree
&quot;2   5 4    1 2
&quot;2   6 7  1 2 3
</pre>
<pre class="code literal-block">
def agree(sx, sy):
    assert all(a==b for a,b in zip(reversed(sx),reversed(sy)))
    return sx if len(sx) &gt;= len(sy) else sy


def get_shape_dyad(op, ranks, sx, sy):
    if not ranks:
        rx, ry = op.rank
        inner = op.get_shape
    else:
        rx, ry = ranks[-1]
        def inner(sx, sy):
            return get_shape_dyad(op, ranks[:-1], sx, sy)

    if rx is None:
        rx = len(sx)
    if ry is None:
        ry = len(sy)

    return inner(sx[:rx], sy[:ry]) + agree(sx[rx:], sy[ry:])


def interp_dyad(op, ranks, sx, vx, sy, vy, vz):
    if not ranks:
        rx, ry = op.rank
        inner = op.interp
    else:
        rx, ry = ranks[-1]
        def inner(sx, vx, sy, vy, vz):
            interp_dyad(op, ranks[:-1], sx, vx, sy, vy, vz)

    if rx is None:
        rx = len(x.shape)

    if ry is None:
        ry = len(y.shape)

    sxo, syo = sx[rx:], sy[ry:]
    px, py = product(sxo), product(syo)

    if len(sxo) &lt;= len(syo):
        common = px
        extra = py/common

        for i in xrange(common):
            for j in xrange(extra):
                inner(sx[:rx], vx.subview(i, px),
                      sy[:ry], vy.subview(i*extra+j, py),
                      vz.subview(i*extra+j, py))
    else:
        common = py
        extra = px/common

        for i in xrange(common):
            for j in xrange(extra):
                inner(sx[:rx], vx.subview(i*extra+j, px),
                      sy[:ry], vy.subview(i, py),
                      vz.subview(i*extra+j, px))


def rankex2(op, ranks, x, y):
    shape = get_shape_dyad(op, ranks, x.shape, y.shape)
    z = Array(shape, [0.0 for _ in xrange(product(shape))])
    interp_dyad(op, ranks, x.shape, x.view(), y.shape, y.view(), z.view())
    return z
</pre>
<p>Plus can be defined like this.</p>
<pre class="code literal-block">
class Plus(object):
    rank = (0,0)

    def get_shape(self, sx, sy):
        return ()

    def interp(self, sx, vx, sy, vy, vz):
        vz[0] = vx[0] + vy[0]


assert rankex2(Plus(), (), Array((2,),[1,2]), Array((2,),[3,4])) == Array((2,),[4,6])
assert rankex2(Plus(), ((0,1),), Array((2,),[1,3]), Array((2,),[3,4])) == Array((2,2),[4,5,6,7])
</pre>
</div>
</body>
</html>
