<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>compilation with integer set library</title>
<link rel="stylesheet" href="html4css1.css" type="text/css" />
</head>
<body>
<div class="document" id="compilation-with-integer-set-library">
<h1 class="title">compilation with integer set library</h1>

<p>We use <a class="reference external" href="http://isl.gforge.inria.fr/">integer set library</a> and <a class="reference external" href="https://pypi.python.org/pypi/islpy">islpy</a> a python binding of isl
in compilation.</p>
<p>We use set in isl to represent arrays and statements. For example,
an array of shape <code>(2,3,4)</code></p>
<pre class="code literal-block">
{A[i,j,k] : 0 &lt;= i &lt; 4, 0 &lt;= j &lt; 3, 0 &lt;= k &lt; 2 }
</pre>
<p>We use map to respresent elements of arrays used in statements, to
keep track of precise relationship between elements of arrays and
statements. For example, <code>C = A + B</code></p>
<pre class="code literal-block">
({S[i] -&gt; C[i] : 0 &lt;= i &lt; 2},
 (call, +,
  (var, {S[i] -&gt; A[i] : 0 &lt;= i &lt; 2}),
  (var, {S[i] -&gt; B[i] : 0 &lt;= i &lt; 2})))
</pre>
<p>And for reduction, <code>B = (reduce 1 +) A</code></p>
<pre class="code literal-block">
init
({S1[] -&gt; B[]}, (const, 0.0))

update
({S2[i] -&gt; B[] : 0 &lt;= i &lt; 2},
 (call, +,
  (var, {S2[i] -&gt; B[] : 0 &lt;= i &lt; 2}),
  (var, {S2[i] -&gt; A[i] : 0 &lt;= i &lt; 2}))
)

fini
({S3[] -&gt; B[]}, (var, {S3[] -&gt; B[]}))
</pre>
<p>So actually, this transformation is easier to implement than
interpretation. For example, <code>compile_monad</code></p>
<pre class="code literal-block">
def compile_monad(ctx, op, ranks, sy, y, z):
    if not ranks:
        ry = op.rank
        inner = op.compile
    else:
        ry = ranks[-1]
        def inner(ctx, sy, y, z):
            compile_monad(ctx, op, ranks[:-1], sy, y, z)

    if ry is None:
        ry = len(sy)

    for s in sy[ry:][::-1]:
        y = ctx.append_dim2(y, s)
        z = ctx.append_dim2(z, s)

    inner(ctx, sy[:ry], y, z)
</pre>
<p>Once all statements are transformed, we use integer set library to
compute a schedule, which will assign a time to each statement. So
that we know when should execute a statement. All use of an element of
an array should be scheduled after it is defined. For reduction
arrays, update statements should be scheduled after init statements,
and fini statements should be scheduled after update statements.</p>
<pre class="code literal-block">
def_map = ctx.def_stmts.get_assign_map().union(ctx.fini_stmts.get_assign_map())
init_map = ctx.init_stmts.get_assign_map()
update_map = ctx.update_stmts.get_assign_map()

use_map = ctx.get_use_map()

validity = (
    def_map.apply_range(use_map.reverse())
    .union(init_map.apply_range(update_map.reverse()))
    .union(update_map.apply_range(def_map.reverse())))
</pre>
<p>Then we use the schedule to build AST, and expand all statements with
their definitions.</p>
</div>
</body>
</html>
